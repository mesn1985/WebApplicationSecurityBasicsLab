# 🔐 Basic Attacks Against Tokens in crAPI

## 🧠 Learning Objectives
- Understand the structure and purpose of JWT tokens.
- Identify insecure implementations of token validation.
- Experiment with JWT manipulation and explore potential impact.
- Recognize the risks of weak or missing token validation mechanisms.

---

## ⚙️ Prerequisites

- Complete the [Basic Authentication Attacks](5_basic_Authentication_Attacks.md) exercise.
- Install the Burp Suite extension [JWT Editor](https://portswigger.net/burp/documentation/desktop/testing-workflow/session-management/jwts).

> 🔍 **Tip**: If the **Extensions** tab is not visible in Burp, go to `View → Extensions`.

---

## 📘 Introduction to JWT Tokens

You’ll begin by exploring the structure and behavior of JWT (JSON Web Token) tokens.

A JWT token consists of:
- **Header** – contains metadata such as algorithm type (e.g., HS256).
- **Payload** – includes claims like `sub`, `iat`, and optionally roles or user data.
- **Signature** – used to verify token integrity (generated by hashing the header and payload with a secret key).

**Important**: Only the signature ensures authenticity. The header and payload are **Base64-encoded**, not encrypted.

### 🧪 Activity: Explore JWT Tokens

Go to [https://jwt.io/](https://jwt.io/) and perform the following:

1. Change the value of `sub`. How drastically does the signature change?
2. Change the value of `iat`. What happens to the signature?
3. Copy and decode the JWT header in a base64 decoder. What metadata do you see?
4. Decode the JWT payload. What claims are visible?

> 🔍 Reflection: Base64 encoding does **not** protect the contents of a JWT. If sensitive data is in the payload, anyone can read it.

---

## 🎭 Manipulating the JWT Payload

This exercise shows how improper validation of JWT tokens can lead to unauthorized data access.

### 🎯 Objective
Demonstrate **information disclosure** by manipulating a JWT's payload and observing a successful response.

You’ll need two accounts: _User A_ and _User B_.

### 📌 Steps

1. As **User A**, log in and capture a **GET** request to the dashboard using Burp Suite.
2. Send the request to **Repeater**.
3. Switch to the **JWT Editor** tab (green-highlighted).
4. In the **payload** section, modify the `email` claim to use **User B’s** email.
5. Click **Send**.
6. Observe: the response now contains **User B’s information**.

> ⚠️ This indicates **improper or missing validation** of the JWT signature on the server side.

### 🔒 Does This Work Everywhere?

1. Capture a **password update** request and send it to Repeater.
2. Replace the token with your modified one from earlier.
3. Send the request.

You should receive a **401 Unauthorized**, indicating the backend correctly validates tokens in this case.

---

## 🧠 Reflection Questions

- Which part of the application accepted the forged token, and why might that be?
- What are the risks of placing roles or user identifiers directly in a JWT payload?
- How can developers securely validate JWT tokens?
- Why is it dangerous to rely solely on client-side claims without signature checks?

---

## ✅ Summary

In this exercise, you discovered that:

- JWTs are **not encrypted**, only encoded.
- Modifying JWT payloads can lead to **information disclosure** when signature checks are absent.
- Proper backend validation of JWTs is essential to prevent unauthorized access.
- Signature verification is **non-negotiable** in any secure authentication mechanism.

> 🧪 **Good practice**: Use strong algorithms like RS256 and always validate signatures on the server.
