# 🔐 Basic Attacks Against Tokens in crAPI

## 🧠 Learning Objectives
- Understand the structure and purpose of JWT tokens.
- Identify insecure implementations of token validation.
- Experiment with JWT manipulation and explore potential impact.
- Recognize the risks of weak or missing token validation mechanisms.

---

## ⚙️ Prerequisites

- Complete the [Basic Authentication Attacks](5_basic_Authentication_Attacks.md) exercise.
- Install the Burp Suite extension [JWT Editor](https://portswigger.net/burp/documentation/desktop/testing-workflow/session-management/jwts).  
> The JWT editor can be installed by selcting _Extensions_  in Burp suite and then install _JWT editor_ from _BApp store_

> 🔍 **Tip**: If the **Extensions** tab is not visible in Burp, go to `View → Extensions`.

---

## 📘 Introduction to JWT Tokens

You’ll begin by exploring the structure and behavior of JWT (JSON Web Token) tokens.

A JWT token consists of:
- **Header** – contains metadata such as algorithm type (e.g., HS256).
- **Payload** – includes claims like `sub`, `iat`, and optionally roles or user data.
- **Signature** – used to verify token integrity (generated by hashing the header and payload with a secret key).

**Important**: Only the signature ensures authenticity. The header and payload are **Base64-encoded**, not encrypted.

### 🧪 Activity: Explore JWT Tokens

Go to [https://jwt.io/](https://jwt.io/) and perform the following using JWT Encoder:

1. Change the value of `sub`. How drastically does the signature change?
2. Change the value of `iat`. What happens to the signature?
3. Copy and decode the JWT header in a base64 decoder. What metadata do you see?
4. Decode the JWT payload. What claims are visible?

> 🔍 Reflection: Base64 encoding does **not** protect the contents of a JWT. If sensitive data is in the payload, anyone can read it. But changing the content of JWT _header_ or _payload_ significantly changes the signature.

---

## 🎭 Manipulating the JWT Payload

This exercise shows how improper validation of JWT tokens can be performed on one endpoint of an API, but
not the other endpoints.

### 🎯 Objective
Demonstrate that different endpoint in the API can validate the tokens differently. You will manipulate, a token,
to confirm that one endpoint does not validate it properly, will another does. The purpose of this exercise is **not to exploit a weakness**

You’ll need two accounts: _User A_ and _User B_.

### 📌 Steps

1. As **User A**, log in and capture a **GET** request to the dashboard using Burp Suite.
> Notice with JWT editor installed, all request that contains a JWT token, is highligthed in green
2. Send the request to **Repeater**.
3. Switch to the **JSON Web token** tab.
4. In the **payload** section, modify the `email` claim to use **User B’s** email.
5. Click **Send**.
6. Observe: the response now contains **User B’s information**.

> ⚠️ This indicates **improper or missing validation** of the JWT signature on the server side.

### 🔒 Does This Work Everywhere?

1. Capture a **password update** request and send it to Repeater.
2. Replace the token with your modified one from earlier.
3. Send the request.

You should receive a **401 Unauthorized**, indicating the backend correctly validates tokens in this case.

---

## 🧠 Reflection Questions

- Which part of the application accepted the forged token, and why might that be?
- What are the risks of placing roles or user identifiers directly in a JWT payload?
- How can developers securely validate JWT tokens?

---

## ✅ Summary

In this exercise, you discovered that:

- Modifying JWT payloads can lead to **information disclosure** when signature checks are absent.
- Proper backend validation of JWTs is essential to prevent unauthorized access.
- Signature verification is **non-negotiable** in any secure authentication mechanism.

> 🧪 **Good practice**: Use strong algorithms like RS256 and always validate signatures on the server.
